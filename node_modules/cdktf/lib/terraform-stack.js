"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TerraformStack = void 0;
const constructs_1 = require("constructs");
const _tokens_1 = require("./_tokens");
const fs = require("fs");
const path = require("path");
const terraform_element_1 = require("./terraform-element");
const util_1 = require("./util");
const terraform_provider_1 = require("./terraform-provider");
const features_1 = require("./features");
const unique_1 = require("./private/unique");
const STACK_SYMBOL = Symbol.for('ckdtf/TerraformStack');
/**
 * @experimental
 */
class TerraformStack extends constructs_1.Construct {
    /**
     * @experimental
     */
    constructor(scope, id) {
        super(scope, id);
        this.rawOverrides = {};
        this.artifactFile = `cdk.tf.json`;
        this.cdktfVersion = constructs_1.Node.of(this).tryGetContext('cdktfVersion');
        Object.defineProperty(this, STACK_SYMBOL, { value: true });
    }
    /**
     * @experimental
     */
    static isStack(x) {
        return x !== null && typeof (x) === 'object' && STACK_SYMBOL in x;
    }
    /**
     * @experimental
     */
    static of(construct) {
        return _lookup(construct);
        function _lookup(c) {
            if (TerraformStack.isStack(c)) {
                return c;
            }
            const node = constructs_1.Node.of(c);
            if (!node.scope) {
                throw new Error(`No stack could be identified for the construct at path '${constructs_1.Node.of(construct).path}'`);
            }
            return _lookup(node.scope);
        }
    }
    /**
     * @experimental
     */
    addOverride(path, value) {
        const parts = path.split('.');
        let curr = this.rawOverrides;
        while (parts.length > 1) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const key = parts.shift();
            // if we can't recurse further or the previous value is not an
            // object overwrite it with an object.
            const isObject = curr[key] != null && typeof (curr[key]) === 'object' && !Array.isArray(curr[key]);
            if (!isObject) {
                curr[key] = {};
            }
            curr = curr[key];
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const lastKey = parts.shift();
        curr[lastKey] = value;
    }
    /**
     * @experimental
     */
    getLogicalId(tfElement) {
        // wrap the allocation for future renaming support
        return this.allocateLogicalId(tfElement);
    }
    /**
     * (experimental) Returns the naming scheme used to allocate logical IDs.
     *
     * By default, uses
     * the `HashedAddressingScheme` but this method can be overridden to customize
     * this behavior.
     *
     * @param tfElement The element for which the logical ID is allocated.
     * @experimental
     */
    allocateLogicalId(tfElement) {
        const node = tfElement.constructNode;
        let stackIndex;
        if (node.tryGetContext(features_1.EXCLUDE_STACK_ID_FROM_LOGICAL_IDS)) {
            stackIndex = node.scopes.indexOf(tfElement.stack);
        }
        else {
            stackIndex = 0;
        }
        const components = node.scopes.slice(stackIndex + 1).map(c => constructs_1.Node.of(c).id);
        return components.length > 0 ? unique_1.makeUniqueId(components, node.tryGetContext(features_1.ALLOW_SEP_CHARS_IN_LOGICAL_IDS)) : '';
    }
    /**
     * @experimental
     */
    allProviders() {
        const providers = [];
        const visit = async (node) => {
            if (node instanceof terraform_provider_1.TerraformProvider) {
                providers.push(node);
            }
            for (const child of constructs_1.Node.of(node).children) {
                visit(child);
            }
        };
        visit(this);
        return _tokens_1.resolve(this, providers);
    }
    /**
     * @experimental
     */
    toTerraform() {
        const tf = {
            "//": {
                metadata: {
                    version: this.cdktfVersion,
                    stackName: constructs_1.Node.of(this).id,
                }
            }
        };
        const elements = terraformElements(this);
        const fragments = elements.map(e => _tokens_1.resolve(this, e.toTerraform()));
        for (const fragment of fragments) {
            util_1.deepMerge(tf, fragment);
        }
        util_1.deepMerge(tf, this.rawOverrides);
        return _tokens_1.resolve(this, tf);
    }
    /**
     * (experimental) Allows this construct to emit artifacts into the cloud assembly during synthesis.
     *
     * This method is usually implemented by framework-level constructs such as `Stack` and `Asset`
     * as they participate in synthesizing the cloud assembly.
     *
     * @experimental
     */
    onSynthesize(session) {
        const resourceOutput = path.join(session.outdir, this.artifactFile);
        fs.writeFileSync(resourceOutput, JSON.stringify(this.toTerraform(), undefined, 2));
    }
}
exports.TerraformStack = TerraformStack;
function terraformElements(node, into = []) {
    if (node instanceof terraform_element_1.TerraformElement) {
        into.push(node);
    }
    for (const child of constructs_1.Node.of(node).children) {
        // Don't recurse into a substack
        if (TerraformStack.isStack(child)) {
            continue;
        }
        terraformElements(child, into);
    }
    return into;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVycmFmb3JtLXN0YWNrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidGVycmFmb3JtLXN0YWNrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDJDQUE0RTtBQUM1RSx1Q0FBbUM7QUFDbkMseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QiwyREFBdUQ7QUFDdkQsaUNBQW1DO0FBQ25DLDZEQUF5RDtBQUN6RCx5Q0FBK0Y7QUFDL0YsNkNBQWdEO0FBRWhELE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsc0JBQXNCLENBQUMsQ0FBQzs7OztBQU94RCxNQUFhLGNBQWUsU0FBUSxzQkFBUzs7OztJQUszQyxZQUFZLEtBQWdCLEVBQUUsRUFBVTtRQUN0QyxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBSkYsaUJBQVksR0FBUSxFQUFFLENBQUE7UUFNckMsSUFBSSxDQUFDLFlBQVksR0FBRyxhQUFhLENBQUM7UUFDbEMsSUFBSSxDQUFDLFlBQVksR0FBRyxpQkFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDLENBQUE7UUFFL0QsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsWUFBWSxFQUFFLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7SUFDN0QsQ0FBQzs7OztJQUVNLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBTTtRQUMxQixPQUFPLENBQUMsS0FBSyxJQUFJLElBQUksT0FBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVEsSUFBSSxZQUFZLElBQUksQ0FBQyxDQUFDO0lBQ25FLENBQUM7Ozs7SUFFTSxNQUFNLENBQUMsRUFBRSxDQUFDLFNBQXFCO1FBQ3BDLE9BQU8sT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRTFCLFNBQVMsT0FBTyxDQUFDLENBQWE7WUFDNUIsSUFBSSxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxF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QUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckYsQ0FBQztDQUNGO0FBbElELHdDQWtJQztBQUVELFNBQVMsaUJBQWlCLENBQUMsSUFBZ0IsRUFBRSxPQUEyQixFQUFFO0lBQ3hFLElBQUksSUFBSSxZQUFZLG9DQUFnQixFQUFFO1FBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDakI7SUFFRCxLQUFLLE1BQU0sS0FBSyxJQUFJLGlCQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRTtRQUMxQyxnQ0FBZ0M7UUFDaEMsSUFBSSxjQUFjLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQUUsU0FBUztTQUFFO1FBRWhELGlCQUFpQixDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztLQUNoQztJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnN0cnVjdCwgSUNvbnN0cnVjdCwgSVN5bnRoZXNpc1Nlc3Npb24sIE5vZGUgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCB7IHJlc29sdmUgfSBmcm9tICcuL190b2tlbnMnXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgVGVycmFmb3JtRWxlbWVudCB9IGZyb20gJy4vdGVycmFmb3JtLWVsZW1lbnQnO1xuaW1wb3J0IHsgZGVlcE1lcmdlIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IFRlcnJhZm9ybVByb3ZpZGVyIH0gZnJvbSAnLi90ZXJyYWZvcm0tcHJvdmlkZXInO1xuaW1wb3J0IHsgRVhDTFVERV9TVEFDS19JRF9GUk9NX0xPR0lDQUxfSURTLCBBTExPV19TRVBfQ0hBUlNfSU5fTE9HSUNBTF9JRFMgfSBmcm9tICcuL2ZlYXR1cmVzJztcbmltcG9ydCB7IG1ha2VVbmlxdWVJZCB9IGZyb20gJy4vcHJpdmF0ZS91bmlxdWUnO1xuXG5jb25zdCBTVEFDS19TWU1CT0wgPSBTeW1ib2wuZm9yKCdja2R0Zi9UZXJyYWZvcm1TdGFjaycpO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlcnJhZm9ybVN0YWNrTWV0YWRhdGEge1xuICByZWFkb25seSBzdGFja05hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgdmVyc2lvbjogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgVGVycmFmb3JtU3RhY2sgZXh0ZW5kcyBDb25zdHJ1Y3Qge1xuICBwdWJsaWMgcmVhZG9ubHkgYXJ0aWZhY3RGaWxlOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgcmF3T3ZlcnJpZGVzOiBhbnkgPSB7fVxuICBwcml2YXRlIHJlYWRvbmx5IGNka3RmVmVyc2lvbjogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcpIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuXG4gICAgdGhpcy5hcnRpZmFjdEZpbGUgPSBgY2RrLnRmLmpzb25gO1xuICAgIHRoaXMuY2RrdGZWZXJzaW9uID0gTm9kZS5vZih0aGlzKS50cnlHZXRDb250ZXh0KCdjZGt0ZlZlcnNpb24nKVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFNUQUNLX1NZTUJPTCwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaXNTdGFjayh4OiBhbnkpOiB4IGlzIFRlcnJhZm9ybVN0YWNrIHtcbiAgICByZXR1cm4geCAhPT0gbnVsbCAmJiB0eXBlb2YoeCkgPT09ICdvYmplY3QnICYmIFNUQUNLX1NZTUJPTCBpbiB4O1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBvZihjb25zdHJ1Y3Q6IElDb25zdHJ1Y3QpOiBUZXJyYWZvcm1TdGFjayB7XG4gICAgcmV0dXJuIF9sb29rdXAoY29uc3RydWN0KTtcblxuICAgIGZ1bmN0aW9uIF9sb29rdXAoYzogSUNvbnN0cnVjdCk6IFRlcnJhZm9ybVN0YWNrICB7XG4gICAgICBpZiAoVGVycmFmb3JtU3RhY2suaXNTdGFjayhjKSkge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZSA9IE5vZGUub2YoYylcblxuICAgICAgaWYgKCFub2RlLnNjb3BlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3RhY2sgY291bGQgYmUgaWRlbnRpZmllZCBmb3IgdGhlIGNvbnN0cnVjdCBhdCBwYXRoICcke05vZGUub2YoY29uc3RydWN0KS5wYXRofSdgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9sb29rdXAobm9kZS5zY29wZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFkZE92ZXJyaWRlKHBhdGg6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIGxldCBjdXJyOiBhbnkgPSB0aGlzLnJhd092ZXJyaWRlcztcblxuICAgIHdoaWxlIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgY29uc3Qga2V5ID0gcGFydHMuc2hpZnQoKSE7XG5cbiAgICAgIC8vIGlmIHdlIGNhbid0IHJlY3Vyc2UgZnVydGhlciBvciB0aGUgcHJldmlvdXMgdmFsdWUgaXMgbm90IGFuXG4gICAgICAvLyBvYmplY3Qgb3ZlcndyaXRlIGl0IHdpdGggYW4gb2JqZWN0LlxuICAgICAgY29uc3QgaXNPYmplY3QgPSBjdXJyW2tleV0gIT0gbnVsbCAmJiB0eXBlb2YoY3VycltrZXldKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoY3VycltrZXldKTtcbiAgICAgIGlmICghaXNPYmplY3QpIHtcbiAgICAgICAgY3VycltrZXldID0ge307XG4gICAgICB9XG5cbiAgICAgIGN1cnIgPSBjdXJyW2tleV07XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBjb25zdCBsYXN0S2V5ID0gcGFydHMuc2hpZnQoKSE7XG4gICAgY3VycltsYXN0S2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcHVibGljIGdldExvZ2ljYWxJZCh0ZkVsZW1lbnQ6IFRlcnJhZm9ybUVsZW1lbnQpOiBzdHJpbmcge1xuICAgIC8vIHdyYXAgdGhlIGFsbG9jYXRpb24gZm9yIGZ1dHVyZSByZW5hbWluZyBzdXBwb3J0XG4gICAgcmV0dXJuIHRoaXMuYWxsb2NhdGVMb2dpY2FsSWQodGZFbGVtZW50KTtcbiAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBwcm90ZWN0ZWQgYWxsb2NhdGVMb2dpY2FsSWQodGZFbGVtZW50OiBUZXJyYWZvcm1FbGVtZW50KTogc3RyaW5nIHtcbiAgICBjb25zdCBub2RlID0gdGZFbGVtZW50LmNvbnN0cnVjdE5vZGVcblxuICAgIGxldCBzdGFja0luZGV4O1xuICAgIGlmIChub2RlLnRyeUdldENvbnRleHQoRVhDTFVERV9TVEFDS19JRF9GUk9NX0xPR0lDQUxfSURTKSkge1xuICAgICAgc3RhY2tJbmRleCA9IG5vZGUuc2NvcGVzLmluZGV4T2YodGZFbGVtZW50LnN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGFja0luZGV4ID0gMDtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY29tcG9uZW50cyA9IG5vZGUuc2NvcGVzLnNsaWNlKHN0YWNrSW5kZXggKyAxKS5tYXAoYyA9PiBOb2RlLm9mKGMpLmlkKTtcbiAgICByZXR1cm4gY29tcG9uZW50cy5sZW5ndGggPiAwID8gbWFrZVVuaXF1ZUlkKGNvbXBvbmVudHMsIG5vZGUudHJ5R2V0Q29udGV4dChBTExPV19TRVBfQ0hBUlNfSU5fTE9HSUNBTF9JRFMpKSA6ICcnO1xuICB9XG5cbiAgcHVibGljIGFsbFByb3ZpZGVycygpOiBUZXJyYWZvcm1Qcm92aWRlcltdIHtcbiAgICBjb25zdCBwcm92aWRlcnM6IFRlcnJhZm9ybVByb3ZpZGVyW10gPSBbXTtcblxuICAgIGNvbnN0IHZpc2l0ID0gYXN5bmMgKG5vZGU6IElDb25zdHJ1Y3QpID0+IHtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVGVycmFmb3JtUHJvdmlkZXIpIHtcbiAgICAgICAgcHJvdmlkZXJzLnB1c2gobm9kZSlcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBOb2RlLm9mKG5vZGUpLmNoaWxkcmVuKSB7XG4gICAgICAgIHZpc2l0KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2aXNpdCh0aGlzKVxuXG4gICAgcmV0dXJuIHJlc29sdmUodGhpcywgcHJvdmlkZXJzKTtcbiAgfVxuXG4gIHB1YmxpYyB0b1RlcnJhZm9ybSgpOiBhbnkge1xuICAgIGNvbnN0IHRmID0ge1xuICAgICAgXCIvL1wiOiB7XG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgdmVyc2lvbjogdGhpcy5jZGt0ZlZlcnNpb24sXG4gICAgICAgICAgc3RhY2tOYW1lOiBOb2RlLm9mKHRoaXMpLmlkLFxuICAgICAgICB9IGFzIFRlcnJhZm9ybVN0YWNrTWV0YWRhdGFcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZWxlbWVudHMgPSB0ZXJyYWZvcm1FbGVtZW50cyh0aGlzKTtcbiAgICBjb25zdCBmcmFnbWVudHMgPSBlbGVtZW50cy5tYXAoZSA9PiByZXNvbHZlKHRoaXMsIGUudG9UZXJyYWZvcm0oKSkpO1xuXG4gICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiBmcmFnbWVudHMpIHtcbiAgICAgIGRlZXBNZXJnZSh0ZiwgZnJhZ21lbnQpO1xuICAgIH1cblxuICAgIGRlZXBNZXJnZSh0ZiwgdGhpcy5yYXdPdmVycmlkZXMpO1xuXG4gICAgcmV0dXJuIHJlc29sdmUodGhpcywgdGYpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uU3ludGhlc2l6ZShzZXNzaW9uOiBJU3ludGhlc2lzU2Vzc2lvbikge1xuICAgIGNvbnN0IHJlc291cmNlT3V0cHV0ID0gcGF0aC5qb2luKHNlc3Npb24ub3V0ZGlyLCB0aGlzLmFydGlmYWN0RmlsZSk7XG4gICAgZnMud3JpdGVGaWxlU3luYyhyZXNvdXJjZU91dHB1dCwgSlNPTi5zdHJpbmdpZnkodGhpcy50b1RlcnJhZm9ybSgpLCB1bmRlZmluZWQsIDIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXJyYWZvcm1FbGVtZW50cyhub2RlOiBJQ29uc3RydWN0LCBpbnRvOiBUZXJyYWZvcm1FbGVtZW50W10gPSBbXSk6IFRlcnJhZm9ybUVsZW1lbnRbXSB7XG4gIGlmIChub2RlIGluc3RhbmNlb2YgVGVycmFmb3JtRWxlbWVudCkge1xuICAgIGludG8ucHVzaChub2RlKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgY2hpbGQgb2YgTm9kZS5vZihub2RlKS5jaGlsZHJlbikge1xuICAgIC8vIERvbid0IHJlY3Vyc2UgaW50byBhIHN1YnN0YWNrXG4gICAgaWYgKFRlcnJhZm9ybVN0YWNrLmlzU3RhY2soY2hpbGQpKSB7IGNvbnRpbnVlOyB9XG5cbiAgICB0ZXJyYWZvcm1FbGVtZW50cyhjaGlsZCwgaW50byk7XG4gIH1cblxuICByZXR1cm4gaW50bztcbn0iXX0=